# Found - AI Matchmaking Dating App

## Project Overview

Found is an AI matchmaking dating app for people serious about finding real partnerships. Users answer 100 deep questions about themselves, and the AI uses these answers to find highly compatible matches. The app emphasizes depth over volume - no swiping, just meaningful connections.

**Current Status**: Beta - Onboarding flow complete with AI profile parsing. Matching features coming soon.

## Tech Stack

- **Framework**: React Native with Expo SDK 54
- **Navigation**: Expo Router (file-based routing)
- **Backend**: Convex (real-time database, no migrations needed)
- **Authentication**: Clerk (phone/SMS auth)
- **AI**: OpenAI API (gpt-4o-mini for profile parsing)
- **Offline Storage**: MMKV v3 with Zustand persist middleware
- **Language**: TypeScript
- **Package Manager**: Bun

## Project Structure

```
app/                    # Expo Router screens (file-based routing)
├── index.tsx          # Landing page (pre-auth) - introduces Found concept
├── _layout.tsx        # Root layout with AuthGate, font loading, splash screen control
├── (auth)/            # Auth screens
│   ├── _layout.tsx    # Auth stack layout
│   ├── sign-in.tsx    # Phone number input
│   └── verify.tsx     # SMS code verification
├── (onboarding)/      # Onboarding flow
│   ├── _layout.tsx    # Onboarding stack layout
│   ├── basics.tsx     # One-per-page: gender, location, sexuality, birthday, height
│   ├── photos.tsx     # Photo upload (6 slots, 2 required)
│   ├── ai-import.tsx  # Choice screen: use AI or answer manually
│   ├── ai-paste.tsx   # AI prompt copy + JSON paste screen
│   ├── questions.tsx  # 100 questions flow with progress bar
│   └── complete.tsx   # Profile analysis display + waitlist screen
├── (tabs)/            # Main tab navigation (post-onboarding)
│   ├── _layout.tsx    # Tab bar layout
│   └── index.tsx      # Home screen
└── profile.tsx        # Profile page (modal)

convex/                # Convex backend
├── schema.ts          # Database schema (users, photos, questions, answers, userProfiles)
├── users.ts           # User mutations/queries + onboarding completion
├── photos.ts          # Photo upload/management
├── questions.ts       # Question queries
├── seedQuestions.ts   # 100 questions seed data + seed mutation
├── answers.ts         # User answer storage + internal query for AI parsing
├── userProfiles.ts    # Structured profile data queries/mutations
├── matching.ts        # Compatibility scoring algorithm
├── storage.ts         # File storage URL generation
├── lib/
│   ├── openai.ts      # OpenAI client wrapper with retry logic
│   └── prompts.ts     # AI extraction prompt templates
└── actions/
    └── parseProfile.ts # Background action to parse answers into structured data

components/            # Reusable components
├── ProgressBar.tsx    # Progress indicator: category name (X/Y), overall progress bar, "X of 100"
├── QuestionCard.tsx   # Renders different question types (multiple_choice, text, essay, scale)
├── AvatarPicker.tsx   # Avatar display + upload with cropping
└── OfflineBanner.tsx  # Shows when device is offline

lib/                   # Utilities
├── theme.ts           # Light theme colors + typography (fonts, fontSizes, spacing, colors)
├── onboarding-flow.ts # Configurable onboarding step order for A/B testing
├── ai-import.ts       # AI prompt generation and JSON response parsing
├── clerk.tsx          # Clerk auth provider
├── convex.tsx         # Convex client provider
├── media.ts           # Image picker utilities
├── avatar.ts          # Avatar upload helpers
├── token-cache.ts     # Clerk token caching
└── offline-auth.ts    # Cached auth state

hooks/                 # Custom React hooks
├── useOfflineSync.ts  # Network detection
├── usePushNotifications.ts # Push notification setup
└── useScreenReady.ts  # Splash screen control + fade-in animation for first screen

stores/                # Zustand stores
└── offline.ts         # Offline state + user caching
```

## Key Conventions

### Styling

- **Light theme only** - Clean, elegant aesthetic
- Inline StyleSheet.create() at bottom of each file
- Import colors, fonts, fontSizes, spacing from `@/lib/theme`
- Typography: System sans-serif for body, Cormorant (serif) for headings
- Color palette (from `lib/theme.ts`):
  - Background: `#FAFAFA`
  - Surface: `#FFFFFF`
  - Text: `#1A1A1A`
  - Text secondary: `#666666`
  - Text muted: `#999999`
  - Primary (buttons): `#000000`
  - Border: `#E5E5E5`
  - Success: `#22c55e`
  - Error: `#ef4444`

### Fonts

- Body text: System font (clean sans-serif)
- Headings: `Cormorant_500Medium`, `Cormorant_700Bold`, `Cormorant_500Medium_Italic`
- Loaded via `@expo-google-fonts/cormorant` in `app/_layout.tsx`
- Access via `fonts.serif`, `fonts.serifBold`, `fonts.serifItalic` from theme

### Navigation

- Use `router.replace()` for auth redirects and when navigation history may be empty
- Use `router.push()` for normal navigation within a flow
- Use `router.back()` only when certain there's navigation history
- Auth flow handled in `app/_layout.tsx` via AuthGate component
- Onboarding uses `router.replace()` for back navigation to avoid errors when history is empty
- Onboarding step saved to database (`onboardingStep` field) for resume on app restart

### Data Fetching (Convex)

- Use `useQuery()` for reading data - automatically real-time
- Use `useMutation()` for writes
- Pass `"skip"` as second argument to conditionally skip queries:
  ```typescript
  const data = useQuery(
    api.users.current,
    userId ? { clerkId: userId } : "skip"
  );
  ```

### Question Types

The app supports 4 question types (defined in `components/QuestionCard.tsx`):
- `multiple_choice`: Radio button selection from options array
- `text`: Single-line text input
- `essay`: Multi-line textarea for longer responses
- `scale`: Slider from min to max with optional labels (uses `@react-native-community/slider`)
  - Auto-populates default middle value so Next button is enabled immediately
  - Shows `scaleMaxLabel`/`scaleMinLabel` when at max/min values
  - Uses local state during drag to prevent glitchy snapping behavior

### Photo Upload

- 6-slot grid layout, first 2 required
- Uses `react-native-image-crop-picker` for cropping (native) or `expo-image-picker` (web fallback)
- Upload flow: pick → crop → upload to Convex storage → save to photos table
- Photos stored with `order` field (0-5) for display order

---

## Database Schema (Convex)

### users
- `clerkId`: string (indexed by `by_clerk_id`)
- `phone`: string (indexed by `by_phone`)
- `name`: string (optional)
- `avatarUrl`: string (optional)
- `gender`: string (optional) - "Man", "Woman", "Non-binary"
- `location`: string (optional) - Auto-detected city/state
- `sexuality`: string (optional) - "Men", "Women", "Everyone"
- `birthdate`: string (optional, ISO date)
- `heightInches`: number (optional)
- `onboardingComplete`: boolean (optional)
- `onboardingStep`: string (optional) - Current step for resume: "basics", "photos", "ai-import", "questions", "complete"
- `waitlistPosition`: number (optional)
- `pushToken`: string (optional)
- `notificationsEnabled`: boolean (optional)
- `reminderHour`: number (optional)
- `reminderMinute`: number (optional)

### photos
- `userId`: Id<"users">
- `storageId`: Id<"_storage">
- `url`: string
- `order`: number (0-5)
- Index: `by_user`

### questions
- `order`: number (1-100)
- `text`: string
- `type`: "multiple_choice" | "text" | "essay" | "scale"
- `options`: string[] (optional, for multiple_choice)
- `category`: string (optional) - 12 categories total
- `scaleMin`, `scaleMax`: number (optional, for scale)
- `scaleMinLabel`, `scaleMaxLabel`: string (optional)
- Index: `by_order`

### answers
- `userId`: Id<"users">
- `questionId`: Id<"questions">
- `value`: string
- `source`: "ai" | "manual" (optional) - Tracks whether answer came from AI import or manual entry
- Indexes: `by_user`, `by_user_question`

### userProfiles (AI-extracted structured data)
- `userId`: Id<"users"> (indexed by `by_user`)
- `values`: string[] - Core values extracted from essays (e.g., ["honesty", "family", "growth"])
- `interests`: string[] - Hobbies and interests (e.g., ["hiking", "cooking", "travel"])
- `dealbreakers`: string[] - Non-negotiables (e.g., ["smoking", "no kids"])
- `traits`: object
  - `introversion`: number (1-10, 1=extrovert, 10=introvert)
  - `adventurousness`: number (1-10)
  - `ambition`: number (1-10)
  - `emotionalOpenness`: number (1-10)
  - `traditionalValues`: number (1-10)
  - `independenceNeed`: number (1-10)
- `relationshipStyle`: object
  - `loveLanguage`: string (from Q64)
  - `conflictStyle`: string (from Q53)
  - `communicationFrequency`: string (from Q57)
  - `financialApproach`: string (from Q67)
  - `aloneTimeNeed`: number (from Q63)
- `familyPlans`: object
  - `wantsKids`: string ("yes", "no", "maybe", "already_has", "open")
  - `kidsTimeline`: string (optional)
  - `familyCloseness`: number (from Q71)
  - `parentingStyle`: string (optional)
- `lifestyle`: object
  - `sleepSchedule`: string (from Q32)
  - `exerciseLevel`: string (from Q24)
  - `dietType`: string (optional, extracted from Q28)
  - `alcoholUse`: string (from Q29)
  - `drugUse`: string (from Q31)
  - `petPreference`: string (extracted from Q23)
  - `locationPreference`: string ("city", "suburb", "rural", "flexible")
- `keywords`: string[] - Combined searchable keywords (15-25)
- `processedAt`: number (timestamp)
- `openaiModel`: string (e.g., "gpt-4o-mini")
- `confidence`: number (0-1 confidence score)

---

## Question Categories (12 total, 100 questions)

1. **Basic Traits** (Q1-12): Commitment level, ethnicity, career, kids, politics, religion
2. **Core Values** (Q13-20): Values, integrity, self-improvement, honesty
3. **Lifestyle & Health** (Q21-35): Pets, exercise, diet, alcohol, drugs, sleep, health
4. **Your Life Story** (Q36-45): Location preferences, dreams, fears, hardships, formative experiences
5. **Social Life** (Q46-52): Social style, weekends, friend dynamics
6. **Communication Style** (Q53-60): Conflict handling, affection, texting, apologies
7. **Relationship Expectations** (Q61-70): Goals, ideal relationship, love language, finances, dealbreakers
8. **Family & Kids** (Q71-78): Family closeness, parenting style, traditions
9. **Intimacy** (Q79-84): Physical intimacy importance, PDA, emotional connection
10. **Love Philosophy** (Q85-90): Soulmates, love definition, relationship advice
11. **Leisure & Quirks** (Q91-95): Hobbies, music, media, quirks
12. **Final Thoughts** (Q96-100): Non-negotiables, passions, motivations

---

## AI Profile Parsing System

### Overview
After a user completes all 100 questions, a background Convex action parses their answers using OpenAI to extract structured data for efficient compatibility matching.

### Architecture Flow
1. User completes onboarding → `completeOnboarding` mutation runs
2. Mutation schedules `parseUserProfile` action via `ctx.scheduler.runAfter(0, ...)`
3. Action fetches all answers with question details
4. Action batches answers by category and runs 5 parallel OpenAI extractions:
   - Values/Interests/Dealbreakers extraction
   - Personality traits scoring (6 dimensions, 1-10 scale)
   - Family plans extraction
   - Lifestyle preferences extraction
   - Keywords extraction
5. Results combined with structured answers (multiple_choice, scale) from database
6. Complete profile saved to `userProfiles` table

### OpenAI Integration (`convex/lib/openai.ts`)
- Lazy-initialized client using `OPENAI_API_KEY` environment variable
- Default model: `gpt-4o-mini` (cost-efficient, ~$0.01-0.02 per user)
- Retry logic with exponential backoff (3 retries)
- JSON response format enforced
- Error handling for rate limits, auth errors, parsing failures

### Prompt Templates (`convex/lib/prompts.ts`)
- `VALUES_INTERESTS_PROMPT`: Extracts values (max 10), interests (max 15), dealbreakers (max 5)
- `PERSONALITY_TRAITS_PROMPT`: Rates 6 personality dimensions on 1-10 scale
- `FAMILY_PLANS_PROMPT`: Extracts kids preference, timeline, parenting style
- `LIFESTYLE_PROMPT`: Extracts diet, pet preference, location preference
- `KEYWORDS_PROMPT`: Generates 15-25 searchable keywords
- `CONFIDENCE_PROMPT`: Rates extraction confidence (0-1)

### Question Groups for Extraction
```typescript
EXTRACTION_QUESTION_GROUPS = {
  valuesInterests: [4, 12, 13, 15, 16, 17, 18, 19, 25, 28, 40, 42, 48, 49, 52, 91, 92, 93, 94, 97, 98],
  personalityTraits: [12, 13, 17, 18, 19, 40, 41, 43, 44, 45, 46, 48, 49, 50, 52, 54, 55, 58, 59, 60, 62, 68, 69, 70, 83, 84, 86, 87, 90, 94],
  familyPlans: [72, 75, 76, 77, 78],
  lifestyle: [23, 25, 28, 35, 39],
  dealbreakers: [19, 50, 65, 96],
  allOpenEnded: [2, 3, 4, 11, 12, 13, 15, 16, 17, 18, 19, 23, 25, 28, 35, 39, 40, 41, 42, 43, 44, 45, 48, 49, 50, 52, 54, 55, 58, 59, 60, 62, 65, 66, 68, 69, 70, 72, 75, 76, 77, 78, 81, 83, 84, 86, 87, 88, 89, 90, 91, 92, 93, 94, 96, 97, 98, 99, 100],
}
```

---

## Compatibility Scoring Algorithm (`convex/matching.ts`)

### Weighted Scoring (total = 100%)
- **Values alignment**: 25% - Jaccard similarity of values arrays
- **Lifestyle compatibility**: 20% - Sleep, exercise, alcohol, drugs, location, pets
- **Relationship style match**: 20% - Love language, conflict style, communication, finances, alone time
- **Family plans alignment**: 15% - Kids preference (with compatibility matrix), family closeness
- **Interest overlap**: 10% - Jaccard similarity of interests arrays
- **Personality complementarity**: 10% - Similarity across 6 trait dimensions

### Scoring Functions
- `calculateArrayOverlap()`: Jaccard similarity for string arrays
- `calculateNumericSimilarity()`: Normalized difference for 1-10 scales
- `calculateCompatibility()`: Returns 0-100 score with detailed breakdown

### Kids Compatibility Matrix
```typescript
// yes + yes = 1.0, yes + no = 0.1, maybe + maybe = 0.8, etc.
kidsCompatibility = {
  yes: { yes: 1, maybe: 0.7, open: 0.8, no: 0.1, already_has: 0.8, unknown: 0.5 },
  no: { no: 1, maybe: 0.4, open: 0.5, yes: 0.1, already_has: 0.2, unknown: 0.5 },
  // ... etc
}
```

---

## Onboarding Flow Details

### Basics Screen (`app/(onboarding)/basics.tsx`)
- **One question per page** with back/next navigation
- **Step 1 - Gender**: "Man", "Woman", "Non-binary" options
- **Step 2 - Interested In**: "Men", "Women", "Everyone" options
- **Step 3 - Location**: "Enable Location" button using `expo-location`, auto-detects city/state
- **Step 4 - Birthday**: `@react-native-community/datetimepicker`, shows calculated age, 18+ note
- **Step 5 - Height**: Slider in feet/inches format

### Photos Screen (`app/(onboarding)/photos.tsx`)
- 6-slot grid, first 2 marked "Required"
- Uses `react-native-image-crop-picker` with 1:1 aspect ratio
- Saves `onboardingStep: "ai-import"` when continuing

### AI Import Screen (`app/(onboarding)/ai-import.tsx`)
- Choice screen: "Use AI to help answer" or "Answer manually"
- If AI: copies prompt to clipboard, navigates to ai-paste screen
- If manual: clears any AI answers, navigates to questions screen
- Back button goes to photos screen

### AI Paste Screen (`app/(onboarding)/ai-paste.tsx`)
- Step 1: "Copy Prompt" button (shows "Prompt Copied" temporarily)
- Step 2: Paste JSON response from ChatGPT/Claude
- Fixed-height scrollable text input for JSON
- Parses JSON, saves answers with `source: "ai"` to database
- Shows success screen with count of imported answers
- Saves `onboardingStep: "questions"` when continuing

### Questions Screen (`app/(onboarding)/questions.tsx`)
- One question per page with progress bar
- Progress bar shows: category name with position (e.g., "Basic Traits (1/12)"), overall progress "X of 100"
- Progress bar fills based on overall question count, not category
- Auto-saves answers with `source: "manual"` on change
- Scale questions auto-populate default value so Next button is enabled
- Resumes at correct question on app reopen (tracks AI vs manual answers)
- First question shows tip: "Your progress is saved automatically"
- Back on first question shows confirmation modal if AI answers exist
- After all questions: prompts to review AI answers or skip to completion

### Complete Screen (`app/(onboarding)/complete.tsx`)
- **Two-screen flow**:
  1. **Profile Analysis Screen**: Shows AI-parsed profile data with Continue button
     - Values (blue tags), Interests (green tags), Dealbreakers (red tags)
     - Personality trait sliders (6 dimensions)
     - Relationship style, Family plans, Lifestyle info grids
     - Keywords tags
     - Loading state while AI processes
  2. **Waitlist Screen**: Shows position number, "coming soon" message, back button to profile

---

## Environment Variables

### Local (.env.local)
```
EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_xxx
EXPO_PUBLIC_CONVEX_URL=https://xxx.convex.cloud
```

### Convex Environment (set via `bunx convex env set`)
```
OPENAI_API_KEY=sk-xxx
```

---

## Running the App

```bash
# Install dependencies
bun install

# Set OpenAI API key in Convex
bunx convex env set OPENAI_API_KEY sk-your-key-here

# Start Convex dev server (keep running in separate terminal)
bunx convex dev

# Seed questions (run once)
bunx convex run seedQuestions:seedQuestions

# Start Expo
bun start

# Press 'i' for iOS simulator
```

---

## Important Notes

- **Development build required** for native modules (image picker, slider)
- iOS-first but works on Android
- Convex handles all real-time sync automatically
- Questions must be seeded before onboarding works
- OpenAI API key must be set in Convex environment for profile parsing
- Profile parsing runs automatically after onboarding completion
- **Splash screen control**: Stays visible until routing is determined and first screen data is loaded
- **Screen transitions**: First screen fades in smoothly using `useScreenReady` hook
- **Onboarding resume**: Uses `onboardingStep` field in database to resume at correct step on app restart

---

## Implemented Features

### ChatGPT/Claude Question Import Flow (IMPLEMENTED)

**Purpose**: Let users skip manually answering questions that ChatGPT/Claude already knows about them from their conversation history.

**User Flow**:
1. After photos, user sees choice screen (`ai-import.tsx`):
   - "Use AI to help answer" - copies prompt, goes to paste screen
   - "Answer manually" - goes directly to questions
2. AI paste screen (`ai-paste.tsx`):
   - "Copy Prompt" button copies detailed prompt with all 100 questions
   - Prompt instructs AI to give verbose answers (2-4 sentences for text/essay)
   - User pastes JSON response into fixed-height scrollable text area
   - "Import Answers" parses JSON and saves to database with `source: "ai"`
3. Success screen shows count: "X of 100 questions answered!"
4. Questions screen shows only unanswered questions
5. After all questions answered, modal asks: "Review AI answers?"
   - Yes: review each AI answer one by one, can edit
   - No: skip to completion
6. Back on first question shows confirmation: "Clear AI answers and go back?"

**Technical Implementation**:
- `lib/ai-import.ts`: `generateAIPrompt()` and `parseAIResponse()` functions
- Answers stored with `source: "ai"` or `source: "manual"` field
- Session AI answers tracked in MMKV for current session review flow
- Database `source` field persists across app restarts
- `clearAiAnswers` mutation deletes all AI-sourced answers for user

---

## Coming Soon Features

These features are planned but not yet implemented.

---

### Match Preview Motivation System

**Purpose**: Keep users engaged through 100 questions by showing them potential matches as they progress. The previews get better as more questions are answered.

**User Flow**:
1. Every 10 questions (at Q10, Q20, Q30... Q90), pause the question flow
2. Show a "match preview" interstitial screen:
   - Display a real user profile (photo + basic info)
   - Ask: "Is this the type of person you're into?"
   - Yes / No buttons
3. User's feedback is captured (helps train the matching algorithm)
4. Show encouraging message: "Great! As you answer more questions, we'll find even better matches for you"
5. Continue to next question

**Key Details**:
- Previews should genuinely improve over time (not random)
- Early previews (Q10-Q30) are broader matches
- Later previews (Q70-Q90) should be more targeted based on answers so far
- This creates a tangible reward loop - user sees the value of answering more questions
- The yes/no feedback becomes training data for the matching algorithm

**Technical Notes**:
- Need real-time or near-real-time matching calculation
- Could use a simpler/faster algorithm for previews vs final matching
- Track preview feedback in database for algorithm training

---

### AI Matchmaker Chat Interface

**Purpose**: After completing 100 questions, users interact with an AI matchmaker through a chat UI (similar to ChatGPT/Claude interfaces). The AI presents matches conversationally.

**Core Experience**:
- Chat interface that looks like modern AI chat apps
- AI matchmaker has a personality - warm, thoughtful, invested in finding you the right person
- NOT a swipe interface - this is intentionally slower and more thoughtful

**Daily Match Flow**:
1. User gets 3 matches per day (delivered via the chat)
2. AI presents ONE match at a time with:
   - Their photos (carousel or grid)
   - AI-written description/summary of the person
   - **Compatibility breakdown**:
     - Reasons why you're compatible (parsed from both users' answers)
     - Potential concerns or differences (honest about mismatches)
   - This is NOT just "you both like hiking" - it's deeper compatibility insights
3. User has two options:
   - "I want to meet them" (Yes)
   - "Ask more questions" (dig deeper before deciding)

**Ask More Questions Feature**:
- User can ask the AI anything about the match
- AI answers based on the match's 100 question answers
- Examples: "What are their views on having kids?", "How important is religion to them?", "What's their relationship with their family like?"
- AI can also answer subjective questions: "Do you think we'd get along?", "What might we argue about?"
- This is very open-ended - AI uses its judgment
- Eventually user must decide Yes or No

**Technical Notes**:
- Chat history persists
- Need to handle "no more matches today" state gracefully
- AI needs access to both users' full answer sets
- Consider rate limiting questions to prevent endless deliberation

---

### Double Opt-In & Automated Date Booking

**Purpose**: Remove the friction of "matching then chatting then planning a date." If both people want to meet, the AI handles everything.

**Matching Flow**:
1. User A says "I want to meet them" on User B's profile
2. User B does NOT immediately know
3. Next day (or next session), AI tells User B: "[User A's name] wants to meet you!"
4. Shows User B the same profile view (photos, compatibility, etc.)
5. User B decides Yes or No
6. If No: User A is never notified (no rejection notification)
7. If Yes: It's a mutual match!

**Date Booking Flow** (after mutual match):
1. AI congratulates both users on the match
2. AI asks each user for their availability:
   - Calendar picker UI
   - "When are you free this week for a date?"
   - Each user submits 3-5 time slots
3. AI finds overlapping availability
4. AI knows both users' locations (from basic info)
5. AI selects a restaurant from a **pre-curated list**:
   - Restaurants vetted for good date vibes
   - Located conveniently between both users
   - Appropriate price point
6. AI books reservation via **Resi API**
7. AI confirms with both users:
   - "You're meeting [Name] at [Restaurant] on [Date] at [Time]!"
   - Add to calendar button

**Pre-Date Chat**:
- Chat between the two users opens **2 hours before the date**
- NOT before - this is intentional
- Prevents endless texting that kills momentum
- Chat is just for logistics: "I'm running 5 min late", "I'm wearing a blue jacket"
- After the date, chat remains open

**Restaurant List**:
- Curated by city/neighborhood
- Criteria: good for conversation (not too loud), romantic but not over-the-top, mid-to-upscale price point
- Need admin interface to manage restaurant list
- Resi API integration for reservations

**Technical Notes**:
- Resi API integration needed
- Calendar/scheduling logic to find overlaps
- Location-based restaurant selection
- Push notifications for match alerts and date reminders
- Handle edge cases: restaurant fully booked, user cancels, etc.
